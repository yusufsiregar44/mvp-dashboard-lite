# Key Invariants

# Team & User Hierarchy - System Invariants

**Business-Friendly Reference Guide**

---

## What Are Invariants?

**Invariants** are rules that must **always be true** in our system, no matter what operations are performed. Think of them as the "laws of physics" for our access control system.

**Why they matter:**

- âœ… Prevent security holes and unauthorized access
- âœ… Ensure predictable behavior
- âœ… Enable automatic cleanup when things change
- âœ… Maintain clear audit trails
- âœ… Prevent system crashes and errors

---

## The 6 Critical Invariants

### **Invariant 1: No Self-Management** ğŸš«

**Rule:** A user cannot manage themselves.

**Why it matters:**

- You can't approve your own access requests
- Breaks accountability ("Alice approved Alice's access to payroll")
- Creates security backdoors

**Example:**

```
âŒ WRONG:
Alice tries to set herself as her own manager
â†’ System must reject this

âœ… CORRECT:
Alice's manager is Bob
â†’ Bob approves Alice's access
â†’ Clear audit trail

```

**Real-world scenario:**

```
Bad: Alice manages Alice
â†’ Alice adds herself to Executive Team
â†’ Alice grants herself access to confidential files
â†’ No oversight, no approval needed
â†’ Security violation!

Good: Bob manages Alice
â†’ Bob adds Alice to Executive Team
â†’ Clear record: "Bob granted Alice access"
â†’ Proper approval workflow maintained

```

---

### **Invariant 2: No Circular Management Chains** ğŸ”„

**Rule:** Management relationships cannot form a circle (A manages B, B manages C, C manages A).

**Why it matters:**

- System would crash trying to figure out who manages who
- Impossible to determine final authority
- Creates infinite loops when calculating access

**Example:**

```
âŒ WRONG:
Alice manages Bob
Bob manages Charlie
Charlie manages Alice  â† Creates a circle!
â†’ System cannot determine hierarchy
â†’ Queries never finish
â†’ System crashes

âœ… CORRECT:
Charlie manages Bob
Bob manages Alice
â†’ Clear hierarchy
â†’ Charlie is at the top
â†’ System works correctly

```

**Visual:**

```
Wrong (Circular):
   Alice
   â†“   â†‘
   Bob  â† â† â† forms a circle
   â†“   â†‘
 Charlie

Correct (Linear):
 Charlie  â† top
   â†“
   Bob
   â†“
  Alice  â† bottom

```

---

---

### **Invariant 3: Direct Access Wins** ğŸ†

**Rule:** A user cannot be both a direct member AND a manager-inherited member of the same team. Direct membership always takes priority.

**Why it matters:**

- Prevents duplicate records
- Clear answer to "Why does user have access?"
- Accurate team member counts
- Never downgrade someone's access

**Example:**

```
Scenario:
1. Alice is a direct member of Sales Team
2. Bob manages Alice
3. Bob joins Sales Team directly

âŒ WRONG:
Sales Team members:
- Alice (direct)
- Bob (direct)
- Bob (manager via Alice)  â† Duplicate! Confusing!

âœ… CORRECT:
Sales Team members:
- Alice (direct)
- Bob (direct)  â† Only one record, direct access wins

```

**Real-world scenario:**

```
Setup:
- Alice is in Team 1 (direct member)
- Bob manages Alice
- Bob gets promoted, joins Team 1 directly

System should:
âœ“ Keep Bob as direct member
âœ“ Not show Bob twice
âœ“ Not downgrade Bob to "manager access"

Query "Why does Bob have access?"
Answer: "Bob is a direct member" (clear and simple)

```

---

### **Invariant 4: Valid Access Chains** ğŸ”—

**Rule:** Each manager's access must point to their **direct subordinate** in the team, not the original user at the bottom.

**Why it matters:**

- Enables correct automatic cleanup when people leave
- Maintains accurate audit trails
- Prevents orphaned permissions

**Example:**

```
Hierarchy: Diana â†’ Charlie â†’ Bob â†’ Alex

Alex joins Team 1:

âŒ WRONG (all point to Alex):
Team 1 members:
- Alex (direct)
- Bob (manager via Alex) âœ“
- Charlie (manager via Alex) âœ— Charlie doesn't manage Alex!
- Diana (manager via Alex) âœ— Diana doesn't manage Alex!

âœ… CORRECT (each points to direct subordinate):
Team 1 members:
- Alex (direct)
- Bob (manager via Alex) âœ“ Bob manages Alex
- Charlie (manager via Bob) âœ“ Charlie manages Bob
- Diana (manager via Charlie) âœ“ Diana manages Charlie

```

**Why this matters for removal:**

```
Scenario: Remove Bob from Team 1

With CORRECT chain:
- Remove Bob
- Check Charlie: "via Bob" â†’ Bob removed â†’ Remove Charlie âœ“
- Check Diana: "via Charlie" â†’ Charlie removed â†’ Remove Diana âœ“
Result: Clean cascade removal

With WRONG chain:
- Remove Bob
- Check Charlie: "via Alex" â†’ Alex still there â†’ Keep Charlie âœ—
- Check Diana: "via Alex" â†’ Alex still there â†’ Keep Diana âœ—
Result: Charlie and Diana have orphaned access!

```

**Simple rule:** Each manager should say "I'm here because of [the person directly below me]"

---

### **Invariant 5: Access Only Through Teams** ğŸ¯

**Rule:** Users can access resources (clients, portfolios) ONLY through team membership. No direct user-to-resource assignments.

**Key point:** A resource can belong to multiple teams simultaneously.

**Why it matters:**

- Automatic access when joining teams
- Automatic cleanup when leaving teams
- Clear audit trail ("Why access?" â†’ "Via Team X")
- Manager inheritance works automatically

**Example:**

```
âŒ WRONG (Direct assignment):
User â†’ Resource connections:
- Alice â†’ Client A (direct)
- Bob â†’ Client A (direct)

Problems:
- Manual maintenance required
- What if Alice leaves team? Still has access!
- No automatic manager inheritance

âœ… CORRECT (Via teams):
Team â†’ Resource connections:
- Team 1 â†’ Client A

User â†’ Team connections:
- Alice â†’ Team 1 (direct)
- Bob â†’ Team 1 (manager via Alice)

Result:
- Both Alice and Bob can access Client A âœ“
- Automatic: Bob inherited access through management âœ“
- Remove Alice from team â†’ Both lose access âœ“

```

**Multi-team access (valid scenario):**

```
Setup:
- Client A assigned to Team 1
- Client A assigned to Team 2 (same client, different teams)
- Alice is in both Team 1 and Team 2

Result:
- Alice has TWO access paths to Client A âœ“
- This is correct! Redundant access is OK

Remove Alice from Team 1:
- Alice still has access via Team 2 âœ“
- Only loses access when removed from ALL teams

Remove Client A from Team 1:
- Alice still has access via Team 2 âœ“
- Only loses access when client removed from ALL her teams

```

**Simple rule:** Resources connect to teams, people connect to teams. Never connect people directly to resources.

---

## Real-World Scenario: All Invariants Together

### **Setup:**

```
Management hierarchy:
Diana manages Charlie
Charlie manages Bob
Bob manages Alex

Alex joins Sales Team
Sales Team has Client A

```

### **What happens (all invariants at work):**

**Step 1: Validations (Invariants 1-3)**

```
Check: Alex â‰  Alex âœ“ (No self-management)
Check: No cycles âœ“ (No circular chains)
â†’ Proceed with adding Alex

```

**Step 2: Add to team (Invariants 4-5)**

```
Add Alex to Sales Team:
- Alex (direct member)

Add Bob (Alex's manager):
- Check: Bob already direct? No
- Add: Bob (manager via Alex) âœ“

Add Charlie (Bob's manager):
- Check: Charlie already direct? No
- Add: Charlie (manager via Bob) âœ“ Not via Alex!

Add Diana (Charlie's manager):
- Check: Diana already direct? No
- Add: Diana (manager via Charlie) âœ“ Not via Alex!

Final Sales Team:
- Alex (direct)
- Bob (manager via Alex)
- Charlie (manager via Bob)
- Diana (manager via Charlie)

```

**Step 3: Resource access (Invariant 6)**

```
Client A assigned to Sales Team:
â†’ ALL team members can now access Client A:
  - Alex (via Sales Team, direct member)
  - Bob (via Sales Team, manager access)
  - Charlie (via Sales Team, manager access)
  - Diana (via Sales Team, manager access)

```

**Step 4: Removal scenario (All invariants)**

```
Remove Bob from Sales Team:

Check Charlie's access:
- Charlie via Bob â†’ Bob being removed
- Does Charlie manage other direct members? No
- Is Charlie a direct member? No
â†’ Remove Charlie âœ“

Check Diana's access:
- Diana via Charlie â†’ Charlie was removed
- Does Diana have other paths? No
â†’ Remove Diana âœ“

Final Sales Team:
- Alex (direct)

Result:
- Only Alex can access Client A now
- Clean cascade removal
- No orphaned permissions

```

---

## Quick Reference: When Each Invariant Applies

| Operation | Invariants to Check |
| --- | --- |
| **Assign manager** | 1, 2, 3, 4, 5 |
| **Add user to team** | 4, 5, 6 |
| **Remove user from team** | 4, 5, 6 |
| **Assign resource to team** | 6 |
| **Remove resource from team** | 6 |
| **Change manager** | 1, 2, 3, 4, 5 |

---

## Summary: The 6 Laws

```
1. No Self-Management
   â†’ You can't be your own boss

2. No Circular Chains
   â†’ No management loops (Aâ†’Bâ†’Câ†’A)

3. Direct Access Wins
   â†’ Never downgrade to manager access

4. Valid Access Chains
   â†’ Each manager says "I'm here because of [person below me]"

5. Access Only Through Teams
   â†’ Resources belong to teams, not individual users
   â†’ Resources can belong to multiple teams

```

---

## What Happens If We Violate These?

| Violation | Consequence |
| --- | --- |
| **Self-management** | Security hole: unlimited self-access |
| **Circular chains** | System crashes, infinite loops |
| **Duplicate access** | Wrong counts, confusing reports |
| **Invalid chains** | Orphaned permissions after removal |
| **Direct resource access** | Manual cleanup, no auto-inheritance |

---

## Key Takeaway

These 5 invariants work together to ensure:

- âœ… **Security**: No unauthorized access
- âœ… **Performance**: System stays fast
- âœ… **Clarity**: Always know why someone has access
- âœ… **Automation**: Access grants and removals work automatically
- âœ… **Integrity**: No orphaned or invalid permissions

**If any invariant is violated, the system is in an invalid state and must be corrected immediately.**

---