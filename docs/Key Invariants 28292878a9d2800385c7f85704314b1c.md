# Key Invariants

# Team & User Hierarchy - System Invariants

**Business-Friendly Reference Guide**

---

## What Are Invariants?

**Invariants** are rules that must **always be true** in our system, no matter what operations are performed. Think of them as the "laws of physics" for our access control system.

**Why they matter:**

- ✅ Prevent security holes and unauthorized access
- ✅ Ensure predictable behavior
- ✅ Enable automatic cleanup when things change
- ✅ Maintain clear audit trails
- ✅ Prevent system crashes and errors

---

## The 6 Critical Invariants

### **Invariant 1: No Self-Management** 🚫

**Rule:** A user cannot manage themselves.

**Why it matters:**

- You can't approve your own access requests
- Breaks accountability ("Alice approved Alice's access to payroll")
- Creates security backdoors

**Example:**

```
❌ WRONG:
Alice tries to set herself as her own manager
→ System must reject this

✅ CORRECT:
Alice's manager is Bob
→ Bob approves Alice's access
→ Clear audit trail

```

**Real-world scenario:**

```
Bad: Alice manages Alice
→ Alice adds herself to Executive Team
→ Alice grants herself access to confidential files
→ No oversight, no approval needed
→ Security violation!

Good: Bob manages Alice
→ Bob adds Alice to Executive Team
→ Clear record: "Bob granted Alice access"
→ Proper approval workflow maintained

```

---

### **Invariant 2: No Circular Management Chains** 🔄

**Rule:** Management relationships cannot form a circle (A manages B, B manages C, C manages A).

**Why it matters:**

- System would crash trying to figure out who manages who
- Impossible to determine final authority
- Creates infinite loops when calculating access

**Example:**

```
❌ WRONG:
Alice manages Bob
Bob manages Charlie
Charlie manages Alice  ← Creates a circle!
→ System cannot determine hierarchy
→ Queries never finish
→ System crashes

✅ CORRECT:
Charlie manages Bob
Bob manages Alice
→ Clear hierarchy
→ Charlie is at the top
→ System works correctly

```

**Visual:**

```
Wrong (Circular):
   Alice
   ↓   ↑
   Bob  ← ← ← forms a circle
   ↓   ↑
 Charlie

Correct (Linear):
 Charlie  ← top
   ↓
   Bob
   ↓
  Alice  ← bottom

```

---

---

### **Invariant 3: Direct Access Wins** 🏆

**Rule:** A user cannot be both a direct member AND a manager-inherited member of the same team. Direct membership always takes priority.

**Why it matters:**

- Prevents duplicate records
- Clear answer to "Why does user have access?"
- Accurate team member counts
- Never downgrade someone's access

**Example:**

```
Scenario:
1. Alice is a direct member of Sales Team
2. Bob manages Alice
3. Bob joins Sales Team directly

❌ WRONG:
Sales Team members:
- Alice (direct)
- Bob (direct)
- Bob (manager via Alice)  ← Duplicate! Confusing!

✅ CORRECT:
Sales Team members:
- Alice (direct)
- Bob (direct)  ← Only one record, direct access wins

```

**Real-world scenario:**

```
Setup:
- Alice is in Team 1 (direct member)
- Bob manages Alice
- Bob gets promoted, joins Team 1 directly

System should:
✓ Keep Bob as direct member
✓ Not show Bob twice
✓ Not downgrade Bob to "manager access"

Query "Why does Bob have access?"
Answer: "Bob is a direct member" (clear and simple)

```

---

### **Invariant 4: Valid Access Chains** 🔗

**Rule:** Each manager's access must point to their **direct subordinate** in the team, not the original user at the bottom.

**Why it matters:**

- Enables correct automatic cleanup when people leave
- Maintains accurate audit trails
- Prevents orphaned permissions

**Example:**

```
Hierarchy: Diana → Charlie → Bob → Alex

Alex joins Team 1:

❌ WRONG (all point to Alex):
Team 1 members:
- Alex (direct)
- Bob (manager via Alex) ✓
- Charlie (manager via Alex) ✗ Charlie doesn't manage Alex!
- Diana (manager via Alex) ✗ Diana doesn't manage Alex!

✅ CORRECT (each points to direct subordinate):
Team 1 members:
- Alex (direct)
- Bob (manager via Alex) ✓ Bob manages Alex
- Charlie (manager via Bob) ✓ Charlie manages Bob
- Diana (manager via Charlie) ✓ Diana manages Charlie

```

**Why this matters for removal:**

```
Scenario: Remove Bob from Team 1

With CORRECT chain:
- Remove Bob
- Check Charlie: "via Bob" → Bob removed → Remove Charlie ✓
- Check Diana: "via Charlie" → Charlie removed → Remove Diana ✓
Result: Clean cascade removal

With WRONG chain:
- Remove Bob
- Check Charlie: "via Alex" → Alex still there → Keep Charlie ✗
- Check Diana: "via Alex" → Alex still there → Keep Diana ✗
Result: Charlie and Diana have orphaned access!

```

**Simple rule:** Each manager should say "I'm here because of [the person directly below me]"

---

### **Invariant 5: Access Only Through Teams** 🎯

**Rule:** Users can access resources (clients, portfolios) ONLY through team membership. No direct user-to-resource assignments.

**Key point:** A resource can belong to multiple teams simultaneously.

**Why it matters:**

- Automatic access when joining teams
- Automatic cleanup when leaving teams
- Clear audit trail ("Why access?" → "Via Team X")
- Manager inheritance works automatically

**Example:**

```
❌ WRONG (Direct assignment):
User → Resource connections:
- Alice → Client A (direct)
- Bob → Client A (direct)

Problems:
- Manual maintenance required
- What if Alice leaves team? Still has access!
- No automatic manager inheritance

✅ CORRECT (Via teams):
Team → Resource connections:
- Team 1 → Client A

User → Team connections:
- Alice → Team 1 (direct)
- Bob → Team 1 (manager via Alice)

Result:
- Both Alice and Bob can access Client A ✓
- Automatic: Bob inherited access through management ✓
- Remove Alice from team → Both lose access ✓

```

**Multi-team access (valid scenario):**

```
Setup:
- Client A assigned to Team 1
- Client A assigned to Team 2 (same client, different teams)
- Alice is in both Team 1 and Team 2

Result:
- Alice has TWO access paths to Client A ✓
- This is correct! Redundant access is OK

Remove Alice from Team 1:
- Alice still has access via Team 2 ✓
- Only loses access when removed from ALL teams

Remove Client A from Team 1:
- Alice still has access via Team 2 ✓
- Only loses access when client removed from ALL her teams

```

**Simple rule:** Resources connect to teams, people connect to teams. Never connect people directly to resources.

---

## Real-World Scenario: All Invariants Together

### **Setup:**

```
Management hierarchy:
Diana manages Charlie
Charlie manages Bob
Bob manages Alex

Alex joins Sales Team
Sales Team has Client A

```

### **What happens (all invariants at work):**

**Step 1: Validations (Invariants 1-3)**

```
Check: Alex ≠ Alex ✓ (No self-management)
Check: No cycles ✓ (No circular chains)
→ Proceed with adding Alex

```

**Step 2: Add to team (Invariants 4-5)**

```
Add Alex to Sales Team:
- Alex (direct member)

Add Bob (Alex's manager):
- Check: Bob already direct? No
- Add: Bob (manager via Alex) ✓

Add Charlie (Bob's manager):
- Check: Charlie already direct? No
- Add: Charlie (manager via Bob) ✓ Not via Alex!

Add Diana (Charlie's manager):
- Check: Diana already direct? No
- Add: Diana (manager via Charlie) ✓ Not via Alex!

Final Sales Team:
- Alex (direct)
- Bob (manager via Alex)
- Charlie (manager via Bob)
- Diana (manager via Charlie)

```

**Step 3: Resource access (Invariant 6)**

```
Client A assigned to Sales Team:
→ ALL team members can now access Client A:
  - Alex (via Sales Team, direct member)
  - Bob (via Sales Team, manager access)
  - Charlie (via Sales Team, manager access)
  - Diana (via Sales Team, manager access)

```

**Step 4: Removal scenario (All invariants)**

```
Remove Bob from Sales Team:

Check Charlie's access:
- Charlie via Bob → Bob being removed
- Does Charlie manage other direct members? No
- Is Charlie a direct member? No
→ Remove Charlie ✓

Check Diana's access:
- Diana via Charlie → Charlie was removed
- Does Diana have other paths? No
→ Remove Diana ✓

Final Sales Team:
- Alex (direct)

Result:
- Only Alex can access Client A now
- Clean cascade removal
- No orphaned permissions

```

---

## Quick Reference: When Each Invariant Applies

| Operation | Invariants to Check |
| --- | --- |
| **Assign manager** | 1, 2, 3, 4, 5 |
| **Add user to team** | 4, 5, 6 |
| **Remove user from team** | 4, 5, 6 |
| **Assign resource to team** | 6 |
| **Remove resource from team** | 6 |
| **Change manager** | 1, 2, 3, 4, 5 |

---

## Summary: The 6 Laws

```
1. No Self-Management
   → You can't be your own boss

2. No Circular Chains
   → No management loops (A→B→C→A)

3. Direct Access Wins
   → Never downgrade to manager access

4. Valid Access Chains
   → Each manager says "I'm here because of [person below me]"

5. Access Only Through Teams
   → Resources belong to teams, not individual users
   → Resources can belong to multiple teams

```

---

## What Happens If We Violate These?

| Violation | Consequence |
| --- | --- |
| **Self-management** | Security hole: unlimited self-access |
| **Circular chains** | System crashes, infinite loops |
| **Duplicate access** | Wrong counts, confusing reports |
| **Invalid chains** | Orphaned permissions after removal |
| **Direct resource access** | Manual cleanup, no auto-inheritance |

---

## Key Takeaway

These 5 invariants work together to ensure:

- ✅ **Security**: No unauthorized access
- ✅ **Performance**: System stays fast
- ✅ **Clarity**: Always know why someone has access
- ✅ **Automation**: Access grants and removals work automatically
- ✅ **Integrity**: No orphaned or invalid permissions

**If any invariant is violated, the system is in an invalid state and must be corrected immediately.**

---