# Key Actions

---

## Overview

This system automatically manages access through two mechanisms:

1. **Team Membership** → When user joins team, managers inherit access
2. **Resource Assignment** → When resource assigned to team, all members can access it

**Hierarchy:** Up to 2-5 levels deep, unlimited managers per user

---

# Key Actions

1. Add User to Team
2. Remove User from Team
3. Assign Manager
4. Remove manager
5. Assign Resource to Team
6. Remove Resource from Team

## Initial Setup (Example State)

```
Users:
  - Alex (IC)
  - Moe (manages Alex)
  - John (manages Moe)

Teams:
  - Team 1

Resources:
  - Client A

```

---

## Action 1: Add User to Team

**What it does:** Adds user to team as direct member + automatically adds all their managers with inherited access

**Scenario:**

```
>>> add_user_to_team('alex_id', 'team1_id')

Output:
✓ Added alex_id to team1_id as DIRECT member
✓ Added moe_id to team1_id as MANAGER (via alex_id)
✓ Added john_id to team1_id as MANAGER (via alex_id)

team_memberships after:
┌──────────┬──────────┬──────────┬──────────────┐
│ team_id  │ user_id  │ access   │ granted_via  │
├──────────┼──────────┼──────────┼──────────────┤
│ team1    │ alex     │ direct   │ NULL         │
│ team1    │ moe      │ manager  │ alex         │
│ team1    │ john     │ manager  │ alex         │
└──────────┴──────────┴──────────┴──────────────┘

Result: Alex, Moe, and John are all now members of Team 1

```

**Logic:**

1. Insert user as direct member
2. Query user's managers (recursive up to 3 levels)
3. Insert each manager as 'manager' type with granted_via = user_id
4. Skip managers who are already direct members

---

## Action 2: Remove User from Team

**What it does:** Removes user from team + removes managers if they have no other path to this team

**Scenario:**

```
>>> remove_user_from_team('alex_id', 'team1_id')

Output:
✓ Removed alex_id from team1_id
✓ Removed moe_id from team1_id (no other path)
✓ Removed john_id from team1_id (no other path)

team_memberships after:
┌──────────┬──────────┬──────────┬──────────────┐
│ team_id  │ user_id  │ access   │ granted_via  │
├──────────┼──────────┼──────────┼──────────────┤
│ (empty)  │          │          │              │
└──────────┴──────────┴──────────┴──────────────┘

Result: Team 1 is now empty. If Client A was assigned, nobody can access it.

```

**Logic:**

1. Delete user's direct membership
2. For each manager who had access via this user:
    - Check if manager has OTHER subordinates still in team
    - Check if manager is a direct member themselves
    - If NO other path AND NOT direct: remove manager's access
    - If has other path OR is direct: keep their access

**Edge Case:**

```
If Bob is also in Team 1:
  team1: [Alex (direct), Bob (direct), Moe (manager via Alex & Bob)]

Remove Alex:
  → Alex removed
  → Moe STAYS (still manages Bob who is in Team 1)

```

---

## Action 3: Assign Manager

**What it does:** Creates manager relationship + manager inherits all user's existing teams + recursively add the manager's manager to the team

**Scenario:**

```
Setup:
- Alex is in Team 1 (direct member)
- Roger manages Moe
- Moe does NOT yet manage Alex

Action: assign_manager(alex, moe)

Step 1: Add Moe as Alex's manager
user_managers_dm:
┌──────────┬────────────┐
│ user_id  │ manager_id │
├──────────┼────────────┤
│ alex     │ moe        │  ← NEW
│ moe      │ roger      │  ← Already exists
└──────────┴────────────┘

Step 2: Get Alex's direct teams → [team1]

Step 3: Add Moe to team1
team_memberships:
┌──────────┬──────────┬──────────┬──────────────┐
│ team_id  │ user_id  │ access   │ granted_via  │
├──────────┼──────────┼──────────┼──────────────┤
│ team1    │ alex     │ direct   │ NULL         │
│ team1    │ moe      │ manager  │ alex         │  ← NEW
└──────────┴──────────┴──────────┴──────────────┘

Step 4: Recursively add Moe's managers
- Get Moe's managers → [roger]
- Add Roger to team1

Final state:
┌──────────┬──────────┬──────────┬──────────────┐
│ team_id  │ user_id  │ access   │ granted_via  │
├──────────┼──────────┼──────────┼──────────────┤
│ team1    │ alex     │ direct   │ NULL         │
│ team1    │ moe      │ manager  │ alex         │ ← granted_via should be ALEX!
│ team1    │ roger    │ manager  │ moe          │  ← granted_via should be MOE!
└──────────┴──────────┴──────────┴──────────────┘
```

**Logic:**

1. Validate: no self-management, no cycles, max depth not exceeded
2. Insert into user_managers_dm
3. Find all teams where user is direct member
4. Add manager to those teams with 'manager' access type

**Validations:**

- ❌ Cannot manage yourself
- ❌ Cannot create cycles (A→B→C→A)

---

## Action 4: Remove Manager

**What it does:** Removes manager relationship + recalculates team access for that manager

**Scenario:**

```
Setup:
  - Roger manages Moe
  - Moe manages Alex
  - Alex is in Team 1
  - Moe has manager access to Team 1 (via Alex)
  - Roger has manager access to Team 1 (via Moe)

>>> remove_manager('alex_id', 'moe_id')

Output:
✓ moe_id no longer manages alex_id
✓ Removed moe_id from team1_id (no other path)
✓ Removed roger_id from team1_id (no other path)
  → moe_id lost access to client_a

user_managers_dm after:
┌──────────┬────────────┐
│ user_id  │ manager_id │
├──────────┼────────────┤
│ (empty)  │            │
└──────────┴────────────┘

team_memberships after:
┌──────────┬──────────┬──────────┬──────────────┐
│ team_id  │ user_id  │ access   │ granted_via  │
├──────────┼──────────┼──────────┼──────────────┤
│ team1    │ alex     │ direct   │ NULL         │
└──────────┴──────────┴──────────┴──────────────┘

Result: Moe no longer manages Alex and lost access to Team 1 and its resources

```

**Logic:**

1. Delete from user_managers_dm
2. For each team where user is direct member:
    - Check if manager has OTHER subordinates in that team
    - Check if manager is direct member themselves
    - If NO other path AND NOT direct: remove manager's inherited access
    - If has other path OR is direct: keep their access
3. Track which clients manager lost access to

**Edge Case:**

```
If Moe manages both Alex and Bob (both in Team 1):
  Remove Moe as manager of Alex:
    → Moe STAYS in Team 1 (still manages Bob)
    → Roger STAYS in Team 1 (still manages Moe)

  Remove Moe as manager of Bob:
    → NOW Moe is removed from Team 1 (no other path)
    → NOW Roger is removed from Team 1 (no other path)

```

---

## Action 5: Assign Resource to Team

**What it does:** Assigns resource to team + all team members (direct + manager) can now access it

**Scenario:**

```
Setup: Team 1 has Alex (direct), Moe (manager), John (manager)

>>> assign_client_to_team('team1_id', 'clienta_id', 'admin_id')

Output:
✓ Assigned clienta_id to team1_id
  → 3 users can now access clienta_id:
    - alex_id (direct member)
    - moe_id (manager via alex_id)
    - john_id (manager via alex_id)

client_to_teams_dm after:
┌──────────┬───────────┐
│ team_id  │ client_id │
├──────────┼───────────┤
│ team1    │ client_a  │
└──────────┴───────────┘

Result: All Team 1 members (direct + managers) can access Client A

```

**Logic:**

1. Insert into client_to_teams_dm
2. Query all team members (direct + manager access)
3. All members automatically gain access (no additional inserts needed)
4. Access is computed via join: team_memberships → client_to_teams_dm

**Important:** A client can belong to multiple teams (many-to-many)

---

## Action 6: Remove Resource from Team

**What it does:** Removes resource from team + members lose access unless they have it via another team

**Scenario:**

```
Setup: Client A is assigned to Team 1 only

>>> remove_client_from_team('team1_id', 'clienta_id')

Output:
✓ Removed clienta_id from team1_id
  → alex_id lost access (no other path)
  → moe_id lost access (no other path)
  → john_id lost access (no other path)

client_to_teams_dm after:
┌──────────┬───────────┐
│ team_id  │ client_id │
├──────────┼───────────┤
│ (empty)  │           │
└──────────┴───────────┘

Result: Nobody can access Client A anymore

```

**Logic:**

1. Delete from client_to_teams_dm
2. For each team member:
    - Check if they have access via ANOTHER team
    - If YES: they keep access (via other team)
    - If NO: they lose access completely

**Multi-Team Scenario:**

```
Setup: Client A assigned to BOTH Team 1 and Team 2
  - Alice in Team 1
  - Charlie in Team 2

Remove Client A from Team 1:
  ✓ Removed clienta_id from team1_id
  → alice_id lost access (no other path)
  → charlie_id STILL has access (via Team 2) ✓

client_to_teams_dm after:
┌──────────┬───────────┐
│ team_id  │ client_id │
├──────────┼───────────┤
│ team2    │ client_a  │  ← Still here
└──────────┴───────────┘

Result: Only Team 1 members lost access; Team 2 members unaffected

```

---

## Access Path Examples

**Direct Access:**

```
Alice → Team 1 (direct member) → Client A

```

**Manager Access (1 level):**

```
Bob → manages Alice → Team 1 (inherited) → Client A

```

**Manager Access (2 levels):**

```
Charlie → manages Bob → manages Alice → Team 1 (inherited) → Client A

```

**Multiple Paths (same resource, different teams):**

```
Alice → Team 1 → Client A
Alice → Team 2 → Client A
(Alice has redundant access - this is OK!)

```

---

## Key Principles

1. **Automatic Inheritance:** Managers always inherit subordinates' team access
2. **Transitive Access:** Team membership grants access to all team resources
3. **Multiple Paths:** Users/resources can have multiple valid access paths
4. **Cleanup on Removal:** System automatically cleans up orphaned access
5. **Path Preservation:** Removing one path doesn't affect other valid paths

---

## Database Tables Summary

```
users_dm              → All users
teams_dm              → All teams
clients_dm            → All resources/clients
user_managers_dm      → Manager relationships (who manages whom)
team_memberships      → Team membership (direct + manager access)
client_to_teams_dm    → Resource assignment (which teams have which clients)

```

---

## Common Queries

**Get user's accessible clients:**

```sql
SELECT DISTINCT c.client_id, c.name, t.name as via_team
FROM team_memberships tm
JOIN client_to_teams_dm ctt ON tm.team_id = ctt.team_id
JOIN clients_dm c ON ctt.client_id = c.client_id
JOIN teams_dm t ON tm.team_id = t.team_id
WHERE tm.user_id = :user_id

```

**Get who can access a client:**

```sql
SELECT DISTINCT u.user_id, u.name, tm.access_type, t.name as via_team
FROM client_to_teams_dm ctt
JOIN team_memberships tm ON ctt.team_id = tm.team_id
JOIN users_dm u ON tm.user_id = u.user_id
JOIN teams_dm t ON tm.team_id = t.team_id
WHERE ctt.client_id = :client_id

```

---

**Document Version:** 1.0

**Last Updated:** 2025-10-01